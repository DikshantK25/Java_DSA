public class Solution {        public char findKthBit(int n, int k) {            // Uncomment either the iterative or recursive implementation            // return findKthBitIterative(n, k);            return findKthBitRecursive(n, k);        }        // Iterative Approach        public char findKthBitIterative(int n, int k) {            StringBuilder currentStr = new StringBuilder("0");            for (int i = 2; i <= n; i++) {                StringBuilder temp = new StringBuilder();                temp.append(currentStr).append("1");                for (int j = currentStr.length() - 1; j >= 0; j--) {                    temp.append(currentStr.charAt(j) == '0' ? '1' : '0');                }                currentStr = temp;            }            return currentStr.charAt(k - 1);        }        // Recursive Approach        public char findKthBitRecursive(int n, int k) {            StringBuilder currentStr = new StringBuilder();            currentStr.append('0');            int curIndex = 1;            solve(n, k, curIndex, currentStr);            return currentStr.charAt(k - 1); // Adjusted to 0-based index        }        public void solve(int n, int k, int curIndex, StringBuilder currentStr) {            if (curIndex == n) {                return;            }            currentStr.append('1');            currentStr.append(reverse(invert(currentStr.toString())));            solve(n, k, curIndex + 1, currentStr);        }        public String invert(String str) {            StringBuilder invertedStr = new StringBuilder();            for (char c : str.toCharArray()) {                invertedStr.append((char) ('0' + '1' - c));            }            return invertedStr.toString();        }        public String reverse(String str) {            return new StringBuilder(str).reverse().toString();        }        // Main Function for Testing        public static void main(String[] args) {            Solution solution = new Solution();            // Example Test Cases            System.out.println("n = 3, k = 1: " + solution.findKthBit(3, 1)); // Output: '0'            System.out.println("n = 4, k = 11: " + solution.findKthBit(4, 11)); // Output: '1'        }    }//    public static String removeOuterParentheses(String S) {//        // Function to remove the outermost//        // parentheses of every primitive//        // substring from the given string////        // Stores the resultant//        // string//        String res = "";////        // Stores the count of//        // opened parentheses//        int count = 0;////        // Traverse the string//        for (int c = 0;//             c < S.length(); c++)//        {//            // If opening parentheses is//            // encountered and their//            // count exceeds 0//            if (S.charAt(c) == '(' &&//                    count++ > 0)////                // Include the character//                res += S.charAt(c);////            // If closing parentheses is//            // encountered and their//            // count is less than count//            // of opening parentheses//            if (S.charAt(c) == ')' &&//                    count-- > 1)////                // Include the character//                res += S.charAt(c);//        }////        // Return the resultant string//        return res;//        }//}//    public static int findPeakElement(ArrayList<Integer> arr) {//        int n = arr.size(); // Size of array////        // Edge cases://        if (n == 1) return 0;//        if (arr.get(0) > arr.get(1)) return 0;//        if (arr.get(n - 1) > arr.get(n - 2)) return n - 1;////        int low = 1, high = n - 2;//        while (low <= high) {//            int mid = (low + high) / 2;////            // If arr[mid] is the peak://            if (arr.get(mid - 1) < arr.get(mid) && arr.get(mid) > arr.get(mid + 1))//                return mid;////            // If we are in the left://            if (arr.get(mid) > arr.get(mid - 1)) low = mid + 1;////                // If we are in the right://                // Or, arr[mid] is a common point://            else high = mid - 1;//        }//        // Dummy return statement//        return -1;//    }////    public static void main(String[] args) {//        ArrayList<Integer> arr =//                new ArrayList<>(Arrays.asList(1, 2, 3, 9 ,4, 5, 6, 7, 8, 5, 1));//        int ans = findPeakElement(arr);//        System.out.println("The peak is at index: " + ans);//    }//}//import java.util.*;////public class TUF{//    public static int findMax(int[] v) {//        int maxi = Integer.MIN_VALUE;;//        int n = v.length;//        //find the maximum://        for (int i = 0; i < n; i++) {//            maxi = Math.max(maxi, v[i]);//        }//        return maxi;//    }////    public static int calculateTotalHours(int[] v, int hourly) {//        int totalH = 0;//        int n = v.length;//        //find total hours://        for (int i = 0; i < n; i++) {//            totalH += Math.ceil((double)(v[i]) / (double)(hourly));//        }//        return totalH;//    }////    public static int minimumRateToEatBananas(int[] v, int h) {//        int low = 1, high = findMax(v);////        //apply binary search://        while (low <= high) {//            int mid = (low + high) / 2;//            int totalH = calculateTotalHours(v, mid);//            if (totalH <= h) {//                high = mid - 1;//            } else {//                low = mid + 1;//            }//        }//        return low;//    }////    public static void main(String[] args) {//        int[] v = {3,6,7,11};//        int h = 7;//        int ans = minimumRateToEatBananas(v, h);//        System.out.println("Koko should eat at least " + ans + " bananas/hr.");//    }//}//////import java.util.*;//public class TUF{//    public static void main(String[] args) {//        int arr[] = {1,1,2,2,2,3,3};//        int k = removeDuplicates(arr);//        System.out.println("The array after removing duplicate elements is ");//        for (int i = 0; i < k; i++) {//            System.out.print(arr[i] + " ");//    }//    }//    static int removeDuplicates(int[] arr) {//        int i = 0;//        for (int j = 1; j < arr.length; j++) {//            if (arr[i] != arr[j]) {//                i++;//                arr[i] = arr[j];//            }//        }//        return i + 1;//    }//}////import java.util.Arrays;////public class TUF {//    public static void main(String[] args){//        int[]  arr={1,2,3,3,5,6,6,6};//        int i=0;//        for(int j = 0; j <arr.length ; j++) {//            if(arr[i]!=arr[j]){//                i++;//                arr[i]=arr[j];////            }//////        }//        System.out.println(Arrays.toString(arr));//    }////    public static int missingNumber(int []a, int N) {////////////        // Outer loop that runs from 1 to N://////        for (int i = 1; i <= N; i++) {////////////            // flag variable to check//////            //if an element exists//////            int flag = 0;////////////            //Search the element using linear search://////            for (int j = 0; j < N - 1; j++) {//////                if (a[j] == i) {////////////                    // i is present in the array://////                    flag = 1;//////                    break;//////                }//////            }////////////            // check if the element is missing//////            //i.e flag == 0:////////////            if (flag == 0) return i;//////        }////////////        // The following line will never execute.//////        // It is just to avoid warnings.//////        return -1;//////    }////////////    public static void main(String args[]) {//////        int N = 5;//////        int a[] = {1, 2, 4, 5};////////////        int ans = missingNumber(a, N);//////        System.out.println("The missing number is: " + ans);////    }////}//